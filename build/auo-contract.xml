<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<dict>
    <entry key="add_primary_key_to_header">
        <int>1</int>
    </entry>
    <entry key="blockstrategy">
        <dict>
            <entry key="maxbackofftime">
                <int>2000</int>
            </entry>
            <entry key="maxblocksize">
                <int>41943040</int>
            </entry>
            <entry key="maxblocktime">
                <int>30000</int>
            </entry>
            <entry key="maxblocktransactions">
                <int>200</int>
            </entry>
            <entry key="maxspecialendtransactionsize">
                <int>1024</int>
            </entry>
            <entry key="maxtxdelay">
                <int>1000</int>
            </entry>
            <entry key="minbackofftime">
                <int>20</int>
            </entry>
            <entry key="mininterblockinterval">
                <int>1000</int>
            </entry>
            <entry key="name">
                <string>net.postchain.base.BaseBlockBuildingStrategy</string>
            </entry>
            <entry key="preemptiveblockbuilding">
                <int>1</int>
            </entry>
        </dict>
    </entry>
    <entry key="config_consensus_strategy">
        <string>HEADER_HASH</string>
    </entry>
    <entry key="configurationfactory">
        <string>net.postchain.gtx.GTXBlockchainConfigurationFactory</string>
    </entry>
    <entry key="gtx">
        <dict>
            <entry key="max_transaction_size">
                <int>31457280</int>
            </entry>
            <entry key="modules">
                <array>
                    <string>net.postchain.rell.module.RellPostchainModuleFactory</string>
                    <string>net.postchain.gtx.StandardOpsGTXModule</string>
                </array>
            </entry>
            <entry key="rell">
                <dict>
                    <entry key="compilerVersion">
                        <string>0.13.14</string>
                    </entry>
                    <entry key="modules">
                        <array>
                            <string>main</string>
                        </array>
                    </entry>
                    <entry key="sources">
                        <dict>
                            <entry key="account/module.rell">
                                <string>module;

import main: ^.main;

enum roles {
    AUO, // mint asset、xfer asset、event log
    AUO_BROKEN_PART,
    AUO_Inventory,
    OTHER, // xfer asset、event log
    CHANNEL, // xfer asset、event log
    WALLET
// event log
}

entity address {
    key id: text;
}

entity address_meta {
    key address: address;
    index address: address;
    desc: text = ''; // Describe the type of address.
    role: roles;
    created_time: timestamp = op_context.last_block_time;
    block_height: integer = op_context.block_height;
    index transaction: transaction = op_context.transaction;
}

function checkAddress(targetAddress: text) {
    require(
        address @? { .id == targetAddress } != null,
        'Contract[Address: ' + targetAddress + ' not found]'
    );

    val addr = address @ { .id == targetAddress };
    return (
        address = addr,
        addrMeta = address_meta @ { .address == addr }
    );
}

operation register(pubkey: text, role: integer, description: text) {
    require(
        address @? { .id == pubkey } == null,
        main.logSpace.title + '[pubkey: ' + pubkey + ' already registered]'
    );
    log('register pub: ', pubkey);
    log('role: ', roles.value(role));

    val acc = create address ( pubkey );
    create address_meta (
        address = acc,
        role = roles.value(role),
        desc = description
    );
}

query getAddresses() {
    return address_meta @* { } (
        addressId = .address.id,
        desc = .desc,
        role = .role,
        createdTime = .created_time
    ).to_gtv_pretty();
}

query getAddressMeta(pubkey: text) {
    return address_meta @ { .address.id == pubkey } (
        desc = .desc,
        role = .role,
        createdTime = .created_time,
        blockHeight = .block_height,
        blockRid = .transaction.block.block_rid,
        txRid = .transaction.tx_rid
    ).to_gtv_pretty();
}
</string>
                            </entry>
                            <entry key="asset/module.rell">
                                <string>module;

import main: ^.main;

enum action_type {
    MINT,
    TRANSFER,
    UPDATE_METADATA,
}

enum asset_type {
    TCON,
    BLU,
    FHD_CELL,
    QHD_CELL,
    UHD_CELL
}

entity asset {
    key id: text;
    type: asset_type;
    issuer: main.core.account.address;
    part_number: text;
    meta_data: text; // JSON
    mutable owner: main.core.account.address;
    create_time: timestamp = op_context.last_block_time;
}

entity history {
    owner: main.core.account.address;
    asset: asset;
    to: main.core.account.address;
    action: action_type;
    created_time: timestamp = op_context.last_block_time;
    block_height: integer = op_context.block_height;
    transaction: transaction = op_context.transaction;
}

operation mintAsset(assetType: text, serialId: text, partNumber: text, metadata: text, minter: text) {
    val mintDetail = main.core.account.checkAddress(minter);
    log('mintId:', mintDetail.address.id);
    log('role:', mintDetail.addrMeta.role);

    require(
        mintDetail.addrMeta.role == main.core.account.roles.AUO,
        main.logSpace.title + "[Only minters can mint assets]"
    );
    require(
        asset @? {
            .id == serialId
        } == null,
        main
            .logSpace
            .title + "[serialId: + " + serialId + " already exists]"
    );

    val assetData = create asset (
        id = serialId,
        type = asset_type.value(assetType),
        issuer = mintDetail.address,
        part_number = partNumber,
        meta_data = metadata,
        owner = mintDetail.address
    );

    create history (
        owner = mintDetail.address,
        asset = assetData,
        to = mintDetail.address,
        action = action_type.MINT
    );
}

operation batchMintAssets(
    assetTypes: list&lt;text&gt;,
    serialIds: list&lt;text&gt;,
    partNumbers: list&lt;text&gt;,
    metaList: list&lt;text&gt;,
    minter: text
) {
    op_context.is_signer(minter.to_bytes());

    val minterDetail = main.core.account.checkAddress(minter);
    require(
        minterDetail.addrMeta.role == main.core.account.roles.AUO,
        main.logSpace.title + "[Only minters can mint assets]"
    );
    require(
        assetTypes.size() == metaList.size() and assetTypes.size() == serialIds.size(),
        main.logSpace.title + "[Name and meta_data array lengths do not match]"
    );

    for (i in range(assetTypes.size())) {
        if (asset @? { .id == serialIds[i] } != null) {
            log(
                'assetId: ' + serialIds[i] + ' duplicate key'
            );
        } else {
            val assetData = create asset (
                id = serialIds[i],
                type = asset_type.value(assetTypes[i]),
                issuer = minterDetail.address,
                part_number = partNumbers[i],
                meta_data = metaList[i],
                owner = minterDetail.address
            );
            create history (
                owner = minterDetail.address,
                asset = assetData,
                to = minterDetail.address,
                action = action_type.MINT
            );
        }
    }
    ;
}

operation transferAsset(assetId: text, operator: text, from: text, to: text) {
    op_context.is_signer(operator.to_bytes());

    val operatorDetail = main.core.account.checkAddress(operator);
    require(
        operatorDetail.addrMeta.role != main.core.account.roles.WALLET,
        main.logSpace.title + '[The WALLET role does not have operation permissions]'
    );

    val fromDetail = main.core.account.checkAddress(from);
    val toDetail = main.core.account.checkAddress(to);
    require(
        asset @? { .id == assetId, .owner == fromDetail.address } != null,
        main.logSpace.title + "[Asset ID " + assetId + " not owned by " + fromDetail.address.id + "]"
    );

    val assetData = asset @ { .id == assetId, .owner == fromDetail.address };
    update assetData ( .owner = toDetail.address );

    create history (
        owner = fromDetail.address,
        asset = assetData,
        to = toDetail.address,
        action = action_type.TRANSFER
    );
}

operation batchTransfer(assetIds: list&lt;text&gt;, operator: text, from: text, to: text) {
    op_context.is_signer(operator.to_bytes());
    log('assetIds: ', assetIds);
    log('operator: ', operator);
    log('from: ', from);
    log('to: ', to);
    val operatorDetail = main.core.account.checkAddress(operator);
    require(
        operatorDetail.addrMeta.role != main.core.account.roles.WALLET,
        main.logSpace.title + '[The WALLET role does not have operation permissions]'
    );

    val fromDetail = main.core.account.checkAddress(from);
    val toDetail = main.core.account.checkAddress(to);
    for (assetId in assetIds) {
        log('assetId:', assetId);
        log('address:', fromDetail.address.id);
        require(
            asset @? { .id == assetId, .owner == fromDetail.address } != null,
            main.logSpace.title + "[assetId: " + assetId + "not found]"
        );

        val assetData = asset @ { .id == assetId, .owner == fromDetail.address };
        update assetData ( .owner = toDetail.address );
        create history (
            owner = fromDetail.address,
            asset = assetData,
            to = toDetail.address,
            action = action_type.TRANSFER
        );
    }
    ;
}

query getAssetByAddress(address: text) {
    val addrDetail = main.core.account.checkAddress(address);
    return asset @* { .owner == addrDetail.address } (
        assetId = .id,
        type = .type,
        partNumber = .part_number,
        issuer = .issuer.id,
        owner = .owner.id,
        createAt = .create_time
    ).to_gtv_pretty();
}

query getAssetById(assetId: text) {
    log('assetId: ', assetId);
    val assetDetail = asset @ { .id == assetId };
    return history @ { .asset == assetDetail, .action == action_type.MINT } (
        id = assetDetail.id,
        type = assetDetail.type,
        issuer = assetDetail.issuer.id,
        metaData = assetDetail.meta_data,
        owner = assetDetail.owner.id,
        createdTime = .created_time,
        blockHeight = .block_height,
        blockRid = .transaction.block.block_rid,
        txRid = .transaction.tx_rid
    ).to_gtv_pretty();
}

query getAssetMeta(assetId: text) {
    return asset @ { .id == assetId } (
        metaData = .meta_data
    ).to_gtv_pretty();
}

query getHistoryByAddress(address: text) {
    val addrDetail = main.core.account.checkAddress(address);
    return history @* { .owner == addrDetail.address } (
        owner = .owner.id,
        asset = .asset.id,
        to = .to.id,
        action = .action,
        createdTime = .created_time,
        blockHeight = .block_height,
        blockRid = .transaction.block.block_rid,
        txRid = .transaction.tx_rid
    ).to_gtv_pretty();
}

query getHistoryByAssetId(assetId: text) { // Return only the history of the asset.
    return history @* { .asset.id == assetId } (
        owner = .owner.id,
        assetId = .asset.id,
        to = .to.id,
        action = .action,
        createdTime = .created_time,
        blockHeight = .block_height,
        blockRid = .transaction.block.block_rid,
        txRid = .transaction.tx_rid
    ).to_gtv_pretty();
}
</string>
                            </entry>
                            <entry key="main.rell">
                                <string>module;

@mount('auoPanelToken')
namespace core {
    import account: ^.account;
    import asset: ^.asset;
    import product: ^.product;
}

namespace logSpace {
    val title = 'Contract';
}
</string>
                            </entry>
                            <entry key="product/module.rell">
                                <string>module;

import main: ^.main;

val logTile = 'Contract';

enum product_action_type {
    CREATE,
    UPDATE,
    TRASHED
}

entity product_detail {
    key owner: main.core.account.address;
    key id: text;// mutable nfts_meta: text; // 
    created_time: timestamp = op_context.last_block_time;
    mutable updated_time: timestamp = op_context.last_block_time;
}

entity product_history {
    index product: product_detail;
    key event_id: text = ("event_" + op_context.transaction.tx_rid.to_hex());
    message: text;
    // note: text;
    action: product_action_type;
    operator: main.core.account.address;
    created_time: timestamp = op_context.last_block_time;
    block_height: integer = op_context.block_height;
    transaction: transaction = op_context.transaction;
}

operation createProduct(operator: text, targetAddress: text, productId: text, message: text) {
    op_context.is_signer(operator.to_bytes());
    val operatorDetail = main.core.account.checkAddress(operator);
    val targetDetail = main.core.account.checkAddress(targetAddress);
    require(
        targetDetail.addrMeta.role == main.core.account.roles.WALLET,
        main
            .logSpace
            .title + "[The targetAddress:" + targetDetail
            .address
            .id + " does not have WALLET role permissions]"
    );

    val productData = create product_detail (
        .owner = targetDetail.address,
        .id = productId
    // .nfts_meta = nftsMeta
    );
    create product_history (
        .product = productData,
        // .nfts_meta = nftsMeta,
        .message = message,
        .action = product_action_type.CREATE,
        .operator = operatorDetail.address
    );
}

// 替換產品零件功能
operation replaceProductAsset(
    operator: text,
    productId: text,
    targetAssetId: text,
    newAssetId: text
) {
    op_context.is_signer(operator.to_bytes());
    require(
        product_detail @? {
            .id == productId
        } != null,
        main
            .logSpace
            .title + "[productId: " + productId + " not found]"
    );
    require(
        (
                main
                .core
                .asset
                    .asset @* {
                    .id == targetAssetId
                }
            )
            .size() &gt; 0,
        main
            .logSpace
            .title + "[targetAssetId: " + targetAssetId + " ]"
    );
    require(
        (
                main
                .core
                .asset
                    .asset @* {
                    .id == newAssetId
                }
            )
            .size() &gt; 0,
        main
            .logSpace
            .title + "[targetAssetId: " + newAssetId + " ]"
    );

    val op = main.core.account.checkAddress(operator); // 操作者資訊
    val product = product_detail @ { .id == productId }; // 產品資訊
    val productOwner = product.owner;

    // 預廢棄資產資訊
    val preReplaceAsset = main.core.asset.asset @ { .id == targetAssetId };
    val preReplaceAssetOwner = preReplaceAsset.owner;

    val newAsset = main.core.asset.asset @ { .id == newAssetId };
    val newAssetOwner = newAsset.owner;

    val burnWallet = main.core.account.address_meta @* {
            .role == op.addrMeta.role,
            .desc == op.addrMeta.role.name + 
            '_BURN_' +
            preReplaceAsset.type.name
        } limit 1;

    update preReplaceAsset ( .owner = burnWallet[0].address ); //報廢資產
    create main.core.asset.history ( //寫上資產轉移紀錄
        .owner = preReplaceAssetOwner,
        .asset = preReplaceAsset,
        .to = burnWallet[0].address,
        .action = main.core.asset.action_type.TRANSFER
    );
    create product_history ( //寫上錢包轉移資產紀錄
        .product = product,
        .message = 'burn assetId: ' + preReplaceAsset.id,
        .action = product_action_type.UPDATE,
        .operator = op.address
    );

    update newAsset ( .owner = productOwner ); // 資產持有者更換成產品擁有者
    create main.core.asset.history ( //寫上新資產的轉移紀錄
        .owner = newAssetOwner,
        .asset = newAsset,
        .to = productOwner,
        .action = main.core.asset.action_type.TRANSFER
    );
    create product_history ( //寫上產品新增資產紀錄
        .event_id = ("event_" + op_context.transaction.tx_rid.to_hex() + "_1"),
        .product = product,
        .message = 'add assetId: ' + newAsset.id,
        .action = product_action_type.UPDATE,
        .operator = op.address
    );
}

operation trashedProduct(operator: text, productId: text, message: text) {
    op_context.is_signer(operator.to_bytes());

    val operatorDetail = main.core.account.checkAddress(operator);
    require(
        operatorDetail.addrMeta.role == main.core.account.roles.AUO,
        main.logSpace.title + '[Operator does not have AUO role permissions]'
    );

    require(
        product_detail @? { .id == productId } != null,
        main.logSpace.title + "[ProductId: " + productId + " not found]"
    );
    val productDetail = product_detail @ { .id == productId };

    require(
        product_history @? { .product == productDetail, .action == product_action_type.TRASHED } != null,
        main.logSpace.title + "[Product already trashed]"
    );

    val events = product_history @* { .product == productDetail } ( @sort_desc .created_time ) limit 1;
    create product_history (
        .product = productDetail,
        .message = message,
        .action = product_action_type.TRASHED,
        .operator = operatorDetail.address,
        .created_time = op_context.last_block_time,
        .block_height = op_context.block_height,
        .transaction = op_context.transaction
    );
}

// query getProductDetail(address: text) {
//     return product_detail@ { .owner.id == address }(
//         id = .id,
//         metaData = .nfts_meta,
//         createdTime = .created_time,
//         updatedTime = .updated_time
//     ).to_gtv_pretty();
// }
query getProductOwner(productId: text) {
    require(product_detail @? { .id == productId } != null, logTile + "[productId: " + productId + " not found]");
    return product_detail @ { .id == productId } (
        ownerPubkey = .owner.id
    ).to_gtv_pretty();
}

query getAssetDetailList(pubkey: text, type: text) {
    return main.core.asset.asset @* { .owner.id == pubkey, .type == main.core.asset.asset_type.value(type) } (
            id = .id,
            type = .type.name,
            issuer = .issuer,
            metadata = .meta_data
        ).to_gtv_pretty();
}

query getAssetListByProductId(productId: text) {
    require(product_detail @? { .id == productId } != null, logTile + "[productId: " + productId + " not found]");
    val productDetail = product_detail @ { .id == productId };
    val owner = productDetail.owner;
    return main.core.asset.asset @* { .owner == owner } (
            id = .id,
            type = .type.value,
            metadata = .meta_data,
            owner = .owner
        ).to_gtv_pretty();
}

query getProductHistory(address: text) {
    val addrDetail = main.core.account.checkAddress(address);
    require(
        product_detail @? { .owner == addrDetail.address } != null,
        logTile + "[Product for owner: " + addrDetail.address.id + " not found]"
    );

    return product_history @* { .product.owner == addrDetail.address } (
        eventId = .event_id,
        // metaData = .nfts_meta,
        message = .message,
        action = .action,
        operator = .operator.id,
        createdTime = .created_time,
        blockHeight = .block_height,
        blockRid = .transaction.block.block_rid
    );
}
</string>
                            </entry>
                        </dict>
                    </entry>
                    <entry key="version">
                        <string>0.13.4</string>
                    </entry>
                </dict>
            </entry>
        </dict>
    </entry>
    <entry key="max_block_future_time">
        <int>10000</int>
    </entry>
    <entry key="query_cache_ttl_seconds">
        <int>0</int>
    </entry>
    <entry key="revolt">
        <dict>
            <entry key="fast_revolt_status_timeout">
                <int>2000</int>
            </entry>
            <entry key="revolt_when_should_build_block">
                <int>1</int>
            </entry>
        </dict>
    </entry>
    <entry key="signers">
        <array>
            <bytea>02C86E998A0CD3E6FC1FE1B571CCCA60A59D8A3C1C6AF7D9446C25489C681F09F3</bytea>
            <bytea>0213DF1E0CCC65DB0BC34AEBC317F304B17868978EAFC873C637C58ECBB04DAB3C</bytea>
            <bytea>038FDE72308A4297F220C48D8ECE3147905F068EFE1908E51D5A25ADBA49A0652A</bytea>
            <bytea>03FEB85B59FADDAA7BD64E81CC2F57473EB220ABEA32A9398C65C0C06FBDEF3290</bytea>
        </array>
    </entry>
    <entry key="txqueuecapacity">
        <int>2500</int>
    </entry>
</dict>
