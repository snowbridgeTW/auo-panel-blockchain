module;

import main: ^.main;

enum action_type {
    MINT,
    TRANSFER,
    UPDATE_METADATA,
}

enum asset_type {
    TCON,
    BLU,
    FHD_CELL,
    QHD_CELL,
    UHD_CELL
}

entity asset {
    key id: text;
    type: asset_type;
    issuer: main.core.account.address;
    part_number: text;
    meta_data: text; // JSON
    mutable owner: main.core.account.address;
    create_time: timestamp = op_context.last_block_time;
}

entity history {
    owner: main.core.account.address;
    asset: asset;
    to: main.core.account.address;
    action: action_type;
    created_time: timestamp = op_context.last_block_time;
    block_height: integer = op_context.block_height;
    transaction: transaction = op_context.transaction;
}

operation mintAsset(assetType: text, serialId: text, partNumber: text, metadata: text, minter: text) {
    val mintDetail = main.core.account.checkAddress(minter);
    log('mintId:', mintDetail.address.id);
    log('role:', mintDetail.addrMeta.role);

    require(
        mintDetail.addrMeta.role == main.core.account.roles.AUO,
        main.logSpace.title + "[Only minters can mint assets]"
    );
    require(
        asset @? {
            .id == serialId
        } == null,
        main
            .logSpace
            .title + "[serialId: + " + serialId + " already exists]"
    );

    val assetData = create asset (
        id = serialId,
        type = asset_type.value(assetType),
        issuer = mintDetail.address,
        part_number = partNumber,
        meta_data = metadata,
        owner = mintDetail.address
    );

    create history (
        owner = mintDetail.address,
        asset = assetData,
        to = mintDetail.address,
        action = action_type.MINT
    );
}

operation batchMintAssets(
    assetTypes: list<text>,
    serialIds: list<text>,
    partNumbers: list<text>,
    metaList: list<text>,
    minter: text
) {
    op_context.is_signer(minter.to_bytes());

    val minterDetail = main.core.account.checkAddress(minter);
    require(
        minterDetail.addrMeta.role == main.core.account.roles.AUO,
        main.logSpace.title + "[Only minters can mint assets]"
    );
    require(
        assetTypes.size() == metaList.size() and assetTypes.size() == serialIds.size(),
        main.logSpace.title + "[Name and meta_data array lengths do not match]"
    );

    for (i in range(assetTypes.size())) {
        if (asset @? { .id == serialIds[i] } != null) {
            log(
                'assetId: ' + serialIds[i] + ' duplicate key'
            );
        } else {
            val assetData = create asset (
                id = serialIds[i],
                type = asset_type.value(assetTypes[i]),
                issuer = minterDetail.address,
                part_number = partNumbers[i],
                meta_data = metaList[i],
                owner = minterDetail.address
            );
            create history (
                owner = minterDetail.address,
                asset = assetData,
                to = minterDetail.address,
                action = action_type.MINT
            );
        }
    }
    ;
}

operation transferAsset(assetId: text, operator: text, from: text, to: text) {
    op_context.is_signer(operator.to_bytes());

    val operatorDetail = main.core.account.checkAddress(operator);
    require(
        operatorDetail.addrMeta.role != main.core.account.roles.WALLET,
        main.logSpace.title + '[The WALLET role does not have operation permissions]'
    );

    val fromDetail = main.core.account.checkAddress(from);
    val toDetail = main.core.account.checkAddress(to);
    require(
        asset @? { .id == assetId, .owner == fromDetail.address } != null,
        main.logSpace.title + "[Asset ID " + assetId + " not owned by " + fromDetail.address.id + "]"
    );

    val assetData = asset @ { .id == assetId, .owner == fromDetail.address };
    update assetData ( .owner = toDetail.address );

    create history (
        owner = fromDetail.address,
        asset = assetData,
        to = toDetail.address,
        action = action_type.TRANSFER
    );
}

operation batchTransfer(assetIds: list<text>, operator: text, from: text, to: text) {
    op_context.is_signer(operator.to_bytes());
    log('assetIds: ', assetIds);
    log('operator: ', operator);
    log('from: ', from);
    log('to: ', to);
    val operatorDetail = main.core.account.checkAddress(operator);
    require(
        operatorDetail.addrMeta.role != main.core.account.roles.WALLET,
        main.logSpace.title + '[The WALLET role does not have operation permissions]'
    );

    val fromDetail = main.core.account.checkAddress(from);
    val toDetail = main.core.account.checkAddress(to);
    for (assetId in assetIds) {
        log('assetId:', assetId);
        log('address:', fromDetail.address.id);
        require(
            asset @? { .id == assetId, .owner == fromDetail.address } != null,
            main.logSpace.title + "[assetId: " + assetId + "not found]"
        );

        val assetData = asset @ { .id == assetId, .owner == fromDetail.address };
        update assetData ( .owner = toDetail.address );
        create history (
            owner = fromDetail.address,
            asset = assetData,
            to = toDetail.address,
            action = action_type.TRANSFER
        );
    }
    ;
}

query getAssetByAddress(address: text) {
    val addrDetail = main.core.account.checkAddress(address);
    return asset @* { .owner == addrDetail.address } (
        assetId = .id,
        type = .type,
        partNumber = .part_number,
        issuer = .issuer.id,
        owner = .owner.id,
        createAt = .create_time
    ).to_gtv_pretty();
}

query getAssetById(assetId: text) {
    log('assetId: ', assetId);
    val assetDetail = asset @ { .id == assetId };
    return history @ { .asset == assetDetail, .action == action_type.MINT } (
        id = assetDetail.id,
        type = assetDetail.type,
        issuer = assetDetail.issuer.id,
        metaData = assetDetail.meta_data,
        owner = assetDetail.owner.id,
        createdTime = .created_time,
        blockHeight = .block_height,
        blockRid = .transaction.block.block_rid,
        txRid = .transaction.tx_rid
    ).to_gtv_pretty();
}

query getAssetMeta(assetId: text) {
    return asset @ { .id == assetId } (
        metaData = .meta_data
    ).to_gtv_pretty();
}

query getHistoryByAddress(address: text) {
    val addrDetail = main.core.account.checkAddress(address);
    return history @* { .owner == addrDetail.address } (
        owner = .owner.id,
        asset = .asset.id,
        to = .to.id,
        action = .action,
        createdTime = .created_time,
        blockHeight = .block_height,
        blockRid = .transaction.block.block_rid,
        txRid = .transaction.tx_rid
    ).to_gtv_pretty();
}

query getHistoryByAssetId(assetId: text) { // Return only the history of the asset.
    return history @* { .asset.id == assetId } (
        owner = .owner.id,
        assetId = .asset.id,
        to = .to.id,
        action = .action,
        createdTime = .created_time,
        blockHeight = .block_height,
        blockRid = .transaction.block.block_rid,
        txRid = .transaction.tx_rid
    ).to_gtv_pretty();
}
