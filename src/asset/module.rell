module;

import account: ^.account;

enum action_type {
    MINT,
    TRANSFER,
    UPDATE_METADATA,
}

entity asset {
    id: byte_array;
    key id;
    name: text;
    issuer: account.address;
    meta_data: text; // IPFS URL
    mutable owner: account.address;
}

entity balance {
    key account.address, asset;
    mutable amount: integer = 0;
}

entity history {
    owner: account.address;
    asset: asset;
    to: account.address;
    action: action_type;
    created_time: timestamp = op_context.last_block_time;
    block_height: integer = op_context.block_height;
    transaction: transaction = op_context.transaction;
}

function ensureBalance(addr: account.address, asset: asset): balance {
    val bal = balance @? { addr, asset };
    return if (bal != null) bal else create balance ( addr, asset, amount = 0 );
}

operation mint_asset(name: text, serialId: text, metaCID: text, minter: byte_array) {
    val mintDetail = account.checkAddress(minter);
    require(mintDetail.addrMeta.role == account.roles.AUO, 
        "Contract[Only minters can mint assets]"
    );
    
    val assetId = serialId.to_bytes();
    val assetData = create asset(
        id = assetId,
        name = name,
        issuer = mintDetail.address,
        meta_data = metaCID,
        owner = mintDetail.address
    );

    create history(
        owner = mintDetail.address,
        asset = assetData,
        to = mintDetail.address,
        action = action_type.MINT
    );
 }

operation batch_mint_assets(names: list<text>, serialIds: list<text>, metaCIDs: list<text>, minter: byte_array) {
    val minterDetail = account.checkAddress(minter);
    require(minterDetail.addrMeta.role == account.roles.AUO, 
        "Contract[Only minters can mint assets]"
    );
    require(names.size() == metaCIDs.size() 
        and names.size() == serialIds.size(), 
        "Contract[Name and meta_data array lengths do not match]"
    );

    for (i in range(names.size())) {
        val assetData = create asset (
            id = serialIds[i].to_bytes(),
            name = names[i],
            issuer = minterDetail.address,
            meta_data = metaCIDs[i],
            owner = minterDetail.address
        );
        create history (
            owner = minterDetail.address,
            asset = assetData,
            to = minterDetail.address,
            action = action_type.MINT
        );
    };
}

operation transfer_asset(assetId: byte_array, operator: byte_array, from: byte_array, to: byte_array) {
    val operatorDetail = account.checkAddress(operator);
    require(operatorDetail.addrMeta.role != account.roles.WALLET, 
        'Contract[The WALLET role does not have operation permissions]'
    );

    val fromDetail = account.checkAddress(from);
    val toDetail = account.checkAddress(to);
    require(asset @? {.id == assetId, .owner == fromDetail.address } != null, 
        "Contract[Not assetId:" + assetId + "]"
    );

    val assetData = asset @ { .id == assetId, .owner == fromDetail.address };
    update assetData ( .owner = toDetail.address );

    create history (
        owner = fromDetail.address,
        asset = assetData,
        to = toDetail.address,
        action = action_type.TRANSFER
    );   
}

operation batch_transfer(assetIds: list<byte_array>, operator: byte_array, from: byte_array, to: byte_array) {
    val operatorDetail = account.checkAddress(operator);
    require(operatorDetail.addrMeta.role != account.roles.WALLET, 
        'Contract[The WALLET role does not have operation permissions]'
    );

    val fromDetail = account.checkAddress(from);
    val toDetail = account.checkAddress(to);
    for (assetId in assetIds) {
        require(asset @? { .id == assetId, .owner == fromDetail.address } != null, 
            "Contract[assetId: " + assetId.to_hex() + "not found]"
        );

        val assetData = asset @ { .id == assetId, .owner == fromDetail.address };
        update assetData ( .owner = toDetail.address );
        create history (
            owner = fromDetail.address,
            asset = assetData,
            to = toDetail.address,
            action = action_type.TRANSFER
        );  
    };
}
