// module;

// entity TokenInfo {
//     key token_index: integer;
//     name: text;
//     icon: text;
//     creator: byte_array;
// }

// entity ERC20Token {
//     key address: byte_array;
//     key token_index: TokenInfo;
//     mutable balance: integer = 0;
// }

// entity Allowance {
//     key owner: byte_array;
//     key spender: byte_array;
//     key token_index: TokenInfo;
//     mutable amount: integer = 0;
// }

// operation init_token(token_index: integer, name: text, icon: text, total_supply: integer, creator: byte_array) {
//     require(op_context.is_signer(creator));
//     create TokenInfo ( token_index, name, icon, creator );
//     create ERC20Token ( creator, TokenInfo@ {.token_index == token_index}, balance = total_supply );
// }

// operation mint_token(token_index: integer, amount: integer, to: byte_array, creator: byte_array) {
//     require(op_context.is_signer(creator));
//     val token_info = TokenInfo @ { .token_index == token_index };
//     require(token_info.creator == creator);

//     val recipient = ERC20Token @? { .address == to, .token_index == token_info };
//     if (recipient != null) {
//         update ERC20Token @ { .address == to, .token_index == token_info } ( .balance = recipient.balance + amount );
//     } else {
//         create ERC20Token ( to, token_info, balance = amount );
//     }
// }

// operation transfer(token_index: integer, from: byte_array, to: byte_array, amount: integer) {
//     require(op_context.is_signer(from));
//     val token_info = TokenInfo @ { .token_index == token_index };
//     val sender = ERC20Token @ { .address == from, .token_index == token_info };
//     require(sender.balance >= amount);

//     val recipient = ERC20Token @? { .address == to, .token_index == token_info };

//     if (recipient != null) {
//         update ERC20Token @ { .address == to, .token_index == token_info } ( .balance = recipient.balance + amount );
//     } else {
//         create ERC20Token ( to, token_info, balance = amount );
//     }

//     update ERC20Token @ { .address == from, .token_index == token_info } ( .balance = sender.balance - amount );
// }

// operation approve(token_index: integer, owner: byte_array, spender: byte_array, amount: integer) {
//     require(op_context.is_signer(owner));
//     val token_info = TokenInfo @ { .token_index == token_index };
//     val allowance = Allowance @? { .owner == owner, .spender == spender, .token_index == token_info };
//     if (allowance != null) {
//         update Allowance @ { .owner == owner, .spender == spender, .token_index == token_info } ( .amount = amount );
//     } else {
//         create Allowance ( owner, spender, token_info, amount = amount );
//     }
// }

// operation transfer_from(
//     token_index: integer,
//     from: byte_array,
//     to: byte_array,
//     amount: integer,
//     spender: byte_array
// ) {
//     require(op_context.is_signer(spender));
//     val token_info = TokenInfo @ { .token_index == token_index };
//     val allowance = Allowance @ { .owner == from, .spender == spender, .token_index == token_info };
//     require(allowance.amount >= amount);

//     val sender = ERC20Token @ { .address == from, .token_index == token_info };
//     require(sender.balance >= amount);

//     val recipient = ERC20Token @? { .address == to, .token_index == token_info };

//     if (recipient != null) {
//         update ERC20Token @ { .address == to, .token_index == token_info } ( .balance = recipient.balance + amount );
//     } else {
//         create ERC20Token ( to, token_info, balance = amount );
//     }

//     update ERC20Token @ { .address == from, .token_index == token_info } ( .balance = sender.balance - amount );
//     update Allowance @ {
//         .owner == from,
//         .spender == spender,
//         .token_index == token_info
//     } (
//         .amount = allowance.amount - amount
//     );
// }

// query balance_of(token_index: integer, owner: byte_array): integer {
//     val token_info = TokenInfo @ { .token_index == token_index };
//     val token = ERC20Token @? { .address == owner, .token_index == token_info };
//     return if (token != null) token.balance else 0;
// }

// query allowance(token_index: integer, owner: byte_array, spender: byte_array): integer {
//     val token_info = TokenInfo @ { .token_index == token_index };
//     val allowance = Allowance @? { .owner == owner, .spender == spender, .token_index == token_info };
//     return if (allowance != null) allowance.amount else 0;
// }

// query token_info(token_index: integer): (text, text, byte_array) {
//     val info = TokenInfo @ { .token_index == token_index };
//     return (info.name, info.icon, info.creator);
// }